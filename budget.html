<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Budgeting App — Proportional Audit</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background:#f7f8fb; color:#222; }
    h1 { text-align:center }
    .controls { display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:8px; flex-wrap:wrap; }
    table { width:100%; border-collapse:collapse; margin-top:12px; }
    th, td { border:1px solid #ddd; padding:8px; text-align:center; }
    th { background:#2b6cb0; color:white; }
    input[type="text"], input[type="number"] { width:100%; box-sizing:border-box; padding:6px; }
    button { padding:8px 12px; }
    #chart-wrap { width:420px; margin:20px auto; }
    .leftover { font-weight:700; text-align:center; margin-top:8px; }
    .over { color:red; }
    .positive { color:green; }
    #suggestions { margin-top:16px; padding:12px; border-radius:6px; background:#fff; box-shadow:0 1px 4px rgba(0,0,0,0.06); }
    .suggestion { padding:8px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; gap:12px; align-items:center; }
    .suggestion:last-child{ border-bottom:none; }
    .flag { font-size:0.9rem; color:#666; }
    .suggestion .amount { font-weight:700; }
    .highlight { background:#fff3f3; }
    .note { font-size:0.9rem; color:#444; margin-top:8px; }
    .combo { background:#f0f9ff; padding:8px; border-radius:6px; margin-top:8px; }
    footer { margin-top:18px; font-size:0.85rem; color:#555; text-align:center; }
    .btn-small { padding:6px 8px; font-size:0.9rem; }
    .row-highlight { background: #fff8e1; }
    .apply-btn { margin-left:10px; }
    .suggested-cut { color: #d9534f; font-weight:700; }
  </style>
</head>
<body>
  <h1>Budgeting App — Proportional Audit Suggestions</h1>

  <div class="controls">
    <label>Monthly Income: $ <input id="income" type="number" value="0" min="0" /></label>
    <button id="addRowBtn">Add Category</button>
    <button id="applySuggestionsBtn">Apply Suggested Cuts</button>
  </div>

  <table>
    <thead>
      <tr><th>Category</th><th>Amount ($)</th><th>Suggested Cut</th><th>Action</th></tr>
    </thead>
    <tbody id="budgetBody"></tbody>
    <tfoot>
      <tr><td style="font-weight:700">Total</td><td id="tableTotal">$0.00</td><td></td><td></td></tr>
    </tfoot>
  </table>

  <div id="chart-wrap"><canvas id="budgetChart" width="400" height="400"></canvas></div>

  <div class="leftover" id="leftoverDisplay">Leftover: $0.00</div>

  <div id="suggestions" style="display:none">
    <h3>Suggested proportional cuts across unnecessary/flexible categories</h3>
    <div id="suggestionList"></div>
    <div class="note">
      Suggestions are proportional across flagged categories (subscriptions, streaming, dining, convenience fees, memberships, premium upgrades, apps, grooming, hobbies, commuting extras, etc.). You can edit keywords in the code to tune detection. Click <em>Apply Suggested Cuts</em> to apply the reductions to the table.
    </div>
  </div>

  <footer>
    Research basis: subscription creep, discretionary spending (meals, entertainment, conveniences) and small recurring fees are common savings targets.
  </footer>

<script>
// === Local Storage Persistence ===
function saveData() {
  const rows = [];
  document.querySelectorAll('#budgetTable tbody tr').forEach(tr => {
    const cells = tr.querySelectorAll('td');
    if (cells.length >= 2) {
      rows.push({
        name: cells[0].innerText,
        amount: parseFloat(cells[1].innerText) || 0
      });
    }
  });
  localStorage.setItem('budgetData', JSON.stringify(rows));
}

function loadData() {
  const saved = localStorage.getItem('budgetData');
  if (saved) {
    try {
      const rows = JSON.parse(saved);
      rows.forEach(item => {
        // You likely have an existing function to add rows; replace this logic if needed
        addRow(item.name, item.amount);
      });
    } catch(e) {
      console.error('Error loading saved budget data:', e);
    }
  }
}

// Call loadData() when page loads
document.addEventListener('DOMContentLoaded', loadData);

/* ---------- App state ---------- */
let expenses = []; // {name, amount, color, suggestedCut}
const budgetBody = document.getElementById('budgetBody');
const incomeInput = document.getElementById('income');
const tableTotal = document.getElementById('tableTotal');
const leftoverDisplay = document.getElementById('leftoverDisplay');
const suggestionsPanel = document.getElementById('suggestions');
const suggestionList = document.getElementById('suggestionList');
const addRowBtn = document.getElementById('addRowBtn');
const applyBtn = document.getElementById('applySuggestionsBtn');

/* ---------- Expanded keywords and reasons ---------- */
const unnecessaryKeywords = {
  'subscription': 'Recurring subscription (check for unused plans).',
  'stream': 'Streaming/entertainment subscriptions can add up.',
  'membership': 'Gym/club memberships often go unused; consider freezing.',
  'coffee': 'Daily coffee purchases are commonly discretionary.',
  'latte': 'Specialty coffee adds recurring costs.',
  'takeout': 'Takeout and delivery fees compound quickly.',
  'delivery': 'Delivery & convenience fees are small but frequent.',
  'dining': 'Dining out is discretionary and easy to trim.',
  'cable': 'Cable/TV packages may be redundant with streaming.',
  'magazine': 'Print subscriptions and extras can be cancelled.',
  'app': 'Paid apps and in-app subscriptions can repeat charges.',
  'premium': 'Premium upgrades are often optional.',
  'warranty': 'Extended warranties often have limited value.',
  'bank': 'Bank fees and penalties are avoidable expenses.',
  'fee': 'Small recurring fees add up over time.',
  'smokes': 'Tobacco is a high-cost discretionary habit.',
  'alcohol': 'Alcohol purchases are discretionary.',
  'taxi': 'Frequent ride-hailing can be reduced.',
  'rideshare': 'Rideshare convenience costs add up.',
  'parking': 'Parking fees and monthly passes may be optimized.',
  'snack': 'Regular snack purchases add recurring cost.',
  'grooming': 'High-frequency grooming/spa subscriptions can be trimmed.',
  'hobby': 'Some hobby spending can be delayed or reduced.',
  'book': 'Paid book services/collections may be optional.',
  'games': 'Paid gaming subscriptions, microtransactions are discretionary.',
  'data': 'Extra mobile/data plans or add-ons may be unnecessary.'
};

/* ---------- Chart setup ---------- */
const ctx = document.getElementById('budgetChart').getContext('2d');
const chart = new Chart(ctx, { type:'pie', data:{labels:[], datasets:[{data:[], backgroundColor:[]}]}, options:{
    responsive: true,
    maintainAspectRatio: false,
    animation: { duration: 0 },responsive:true, plugins:{legend:{position:'bottom',
    responsive: true,
    maintainAspectRatio: false,
    animation: { duration: 0 }}}} });

/* ---------- Helpers ---------- */
function randColor(){ return '#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0'); }
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function sumExpenses(){ return expenses.reduce((s,e)=> s + (Number(e.amount)||0),0); }

/* ---------- Row management ---------- */
function addRow(name='', amount=0){
  const idx = expenses.length;
  const color = randColor();
  expenses.push({name, amount: Number(amount)||0, color, suggestedCut:0});
  renderTable();
  updateAll();
}
function removeRow(i){ expenses.splice(i,1); renderTable(); updateAll(); }
function renderTable(){
  budgetBody.innerHTML = '';
  expenses.forEach((e,i)=>{
    const tr = document.createElement('tr');
    tr.dataset.index = i;
    tr.innerHTML = `
      <td><input type="text" class="catName" value="${escapeHtml(e.name)}" /></td>
      <td><input type="number" class="catAmt" value="${Number(e.amount)}" min="0" /></td>
      <td class="suggested-cell"><span class="suggested-cut">$${(Number(e.suggestedCut)||0).toFixed(2)}</span></td>
      <td><button class="delBtn btn-small">Delete</button></td>
    `;
    budgetBody.appendChild(tr);
    tr.querySelector('.catName').addEventListener('input', (ev)=>{ expenses[i].name = ev.target.value; updateAll(); });
    tr.querySelector('.catAmt').addEventListener('input', (ev)=>{ expenses[i].amount = Number(ev.target.value)||0; updateAll(); });
    tr.querySelector('.delBtn').addEventListener('click', ()=> removeRow(i));
  });
}

/* ---------- Detection of flexible (unnecessary) categories ---------- */
function detectFlexibleCandidates(){
  const candidates = [];
  for(let i=0;i<expenses.length;i++){
    const name = (expenses[i].name||'').toLowerCase();
    for(const kw in unnecessaryKeywords){
      if(name.includes(kw)){
        candidates.push({index:i, name:expenses[i].name||'(unnamed)', amount: Number(expenses[i].amount)||0, reason: unnecessaryKeywords[kw]});
        break;
      }
    }
  }
  return candidates;
}

/* ---------- Proportional reduction algorithm ----------
   Spread the deficit across flexible candidates proportionally to their amounts.
   Do iterative cap to ensure we don't reduce more than the category amount.
*/
function proportionalReduce(deficit, candidateIndices){
  // deficit is positive number (amount we need to cut)
  // candidateIndices: array of indices into expenses
  const cuts = {}; // index -> cut amount
  candidateIndices.forEach(i=> cuts[i]=0);
  // Work on amounts in dollars
  let remainingDeficit = deficit;
  // Make a working list with current remaining amounts
  let remainingCandidates = candidateIndices.slice();
  // Iteratively distribute proportional cuts and cap at category amount
  while(remainingDeficit > 0.0001 && remainingCandidates.length > 0){
    // sum of remaining amounts
    let sumAmounts = 0;
    remainingCandidates.forEach(i=> sumAmounts += Math.max(0, Number(expenses[i].amount) - (cuts[i] || 0)));
    if(sumAmounts <= 0) break;
    // allocate proportionally
    let anyCapped = false;
    remainingCandidates.forEach(i=>{
      const avail = Math.max(0, Number(expenses[i].amount) - (cuts[i] || 0));
      const portion = (avail / sumAmounts) * remainingDeficit;
      const toTake = Math.min(avail, Math.round(portion*100)/100); // round to cents
      cuts[i] = (cuts[i] || 0) + toTake;
      if(Math.abs(avail - toTake) < 0.001) anyCapped = true;
    });
    // subtract what we allocated
    let allocated = 0;
    remainingCandidates.forEach(i=> allocated += (cuts[i] || 0));
    // compute total allocated this round by summing cuts? Better to compute delta per index
    // We'll compute allocated this iteration by summing min(availBefore, allocatedAmountIncrease); easier: track previous totals
    // Simpler: recompute remainingDeficit by summing available left
    let totalCuts = 0;
    for(const idx in cuts) totalCuts += cuts[idx];
    // remainingDeficit equals deficit - totalCuts
    remainingDeficit = Math.max(0, deficit - totalCuts);
    // update remainingCandidates to those with still avail > 0
    remainingCandidates = remainingCandidates.filter(i=> (Number(expenses[i].amount) - (cuts[i] || 0)) > 0.009 );
    // safety break to avoid infinite loop
    if(!anyCapped && remainingDeficit > 0) {
      // slight numerical issue; break to avoid infinite loop
      break;
    }
  }
  // Ensure amounts are rounded to cents and do not exceed original amounts
  for(const idx in cuts){
    cuts[idx] = Math.min(Number(expenses[idx].amount), Math.round((cuts[idx] || 0)*100)/100);
  }
  return cuts;
}

/* ---------- Compute suggestions ---------- */
function computeSuggestions(income){
  const total = sumExpenses();
  const leftover = income - total;
  const result = {leftover, total, income, candidates:[], cuts:{}, flexibleIndices:[]};
  if(leftover >= 0) return result;
  const deficit = Math.abs(leftover);
  // detect flexible candidates
  const candidates = detectFlexibleCandidates();
  const flexibleIndices = candidates.map(c=>c.index);
  // if no flexible candidates, fallback to top 5 largest
  if(flexibleIndices.length === 0){
    const sorted = expenses.map((e,i)=>({i,amt:Number(e.amount)||0})).sort((a,b)=>b.amt-a.amt);
    for(let j=0;j<Math.min(5, sorted.length); j++) flexibleIndices.push(sorted[j].i);
  }
  // compute proportional cuts across flexibleIndices
  const cuts = proportionalReduce(deficit, flexibleIndices);
  // prepare candidates list with reasons and amounts
  const enriched = flexibleIndices.map(i=> ({
    index:i, name:expenses[i].name||'(unnamed)', amount: Number(expenses[i].amount)||0,
    reason: (function(){ // find matched keyword reason if possible
      const nm = (expenses[i].name||'').toLowerCase();
      for(const kw in unnecessaryKeywords) if(nm.includes(kw)) return unnecessaryKeywords[kw];
      return 'Large flexible expense; consider trimming.';
    })(),
    suggestedCut: cuts[i] || 0
  }));
  result.candidates = enriched;
  result.cuts = cuts;
  result.flexibleIndices = flexibleIndices;
  return result;
}

/* ---------- Update UI ---------- */
function updateAll(){
  const income = Number(incomeInput.value)||0;
  const total = sumExpenses();
  const leftover = income - total;
  tableTotal.textContent = `$${total.toFixed(2)}`;
  leftoverDisplay.textContent = `Leftover: $${leftover.toFixed(2)}`;
  leftoverDisplay.className = 'leftover ' + (leftover < 0 ? 'over':'positive');

  // prepare chart
  const labels = [];
  const data = [];
  const colors = [];
  expenses.forEach(e=>{
    if(e.name && Number(e.amount)>0){
      labels.push(e.name);
      data.push(Number(e.amount));
      colors.push(e.color);
    }
  });
  if(income > 0){
    if(leftover >= 0){
      labels.push('Unbudgeted');
      data.push(leftover);
      colors.push('#cccccc');
    } else {
      labels.push('Over Budget');
      data.push(Math.abs(leftover));
      colors.push('#ff4d4d');
    }
  }
  chart.data.labels = labels;
  chart.data.datasets[0].data = data;
  chart.data.datasets[0].backgroundColor = colors;
  chart.update();

  // suggestions when over budget
  if(leftover < 0){
    const s = computeSuggestions(income);
    renderSuggestions(s);
  } else {
    suggestionsPanel.style.display = 'none';
    // clear suggestedCut in table cells
    expenses.forEach(e=> e.suggestedCut = 0);
    renderTable();
  }
}

/* ---------- Render suggestions ---------- */
function renderSuggestions(s){
  suggestionList.innerHTML = '';
  suggestionsPanel.style.display = 'block';
  if(s.candidates.length===0){
    suggestionList.innerHTML = `<div>No obvious candidates detected. Consider auditing subscriptions, delivery and dining, and small recurring fees.</div>`;
    return;
  }
  // mark suggested cuts in expenses data and in table
  expenses.forEach(e => e.suggestedCut = 0);
  s.candidates.forEach(c=> { expenses[c.index].suggestedCut = c.suggestedCut || 0; });
  renderTable();
  // highlight rows and show details
  s.candidates.forEach(c=>{
    const div = document.createElement('div');
    div.className = 'suggestion';
    div.innerHTML = `
      <div style="max-width:70%">
        <div style="font-weight:700">${escapeHtml(c.name)}</div>
        <div class="flag">${escapeHtml(c.reason)}</div>
      </div>
      <div style="text-align:right">
        <div class="amount suggested-cut">$${Number(c.suggestedCut).toFixed(2)}</div>
        <div style="font-size:0.9rem; color:#666">${Number(c.suggestedCut) >= Number(c.amount) ? 'Full removal suggested' : 'Partial reduction suggested'}</div>
      </div>
    `;
    suggestionList.appendChild(div);
  });
  const totalCuts = Object.values(s.cuts).reduce((a,b)=>a+(Number(b)||0),0);
  const comboDiv = document.createElement('div');
  comboDiv.className = 'note';
  comboDiv.innerHTML = `<strong>Total suggested cuts:</strong> $${totalCuts.toFixed(2)} (needed: $${Math.abs(s.leftover).toFixed(2)})`;
  suggestionList.appendChild(comboDiv);
}

/* ---------- Apply suggested cuts to table ---------- */
function applySuggestedCuts(){
  // apply expenses[i].suggestedCut by subtracting from amount
  expenses.forEach((e,i)=>{
    if(Number(e.suggestedCut) > 0){
      e.amount = Math.max(0, Number(e.amount) - Number(e.suggestedCut));
      e.suggestedCut = 0;
    }
  });
  renderTable();
  updateAll();
}

/* ---------- Wiring ---------- */
addRowBtn.addEventListener('click', ()=> addRow('New Category', 0));
applyBtn.addEventListener('click', ()=> applySuggestedCuts());
incomeInput.addEventListener('input', updateAll);

/* seed rows */
addRow('Rent', 1200);
addRow('Streaming subscription', 19.99);
addRow('Coffee Runs', 120);
addRow('Groceries', 350);
addRow('Personal Loans', 450);
addRow('Mobile data premium', 25);
addRow('Takeout/delivery', 150);

/* initial render */
renderTable();
updateAll();

</script>
</body>
</html>
